// 
//  Transform.cs (generated by template)
//  
//  Author:
//       Anders Frisk <andersfrisk77@gmail.com>
//  
//  Copyright (c) 2011 Anders Frisk
// 
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
// 
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
// 
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

using System;
using NUnit.Framework;
using Kean.Math.Geometry2D;
using Target = Kean.Math.Geometry3D;
using Kean.Extension;

namespace Kean.Math.Geometry3D.Test.Double
{
	[TestFixture]
	public class Transform :
	Kean.Test.Fixture<Transform>
	{
		double Precision { get { return 1e-5f; } }
		Target.Double.Transform CastFromString(string value)
		{
			return (Kean.Math.Geometry3D.Double.Transform)value;
		}
		string CastToString(Kean.Math.Geometry3D.Double.Transform value)
		{
			return (string)value;
		}
			Target.Double.Transform Transform0 = new Kean.Math.Geometry3D.Double.Transform(-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
			Target.Double.Transform Transform1 = new Kean.Math.Geometry3D.Double.Transform(-1, 2, 3, 4, 5, 6, 7, 8, -5, 10, 11, 12);
			Target.Double.Transform Transform2 = new Kean.Math.Geometry3D.Double.Transform(30, 32, 36, 58, 81, 96, -10, 14, 24, 128, 182, 216);
			Target.Double.Transform Transform3 = new Kean.Math.Geometry3D.Double.Transform(-0.5f, 1, -0.5f, 1, -5, 3, -0.5f, 3.66666666666666f, -2.16666666666667f, 0, 1, -2);
			Target.Double.Transform Transform4 = new Target.Double.Transform(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120);	
			Target.Double.Point Point0 = new Kean.Math.Geometry3D.Double.Point(34, 10, 30);
			Target.Double.Point Point1 = new Kean.Math.Geometry3D.Double.Point(226, 369, 444);
		protected override void Run()
		{

			this.Run(
				this.InverseTransform1,
				this.InverseTransform2,
				this.InverseTransform3,
				this.Equality,
				this.CreateZeroTransform,
				this.CreateIdentity,
				this.CreateRotation,
				this.CreateScale,
				this.CreateTranslation,
				this.Rotate,
				this.Scale,
				this.Translatate,
				this.InverseTransform,
				this.MultiplicationTransformTransform,
				this.MultiplicationTransformPoint,
				this.GetTranslation,
				this.GetScalingX,
				this.GetScalingY,
				this.GetScalingZ,
				this.GetScaling,
				this.CastToArray,
				this.MultiplicationTransformTransform,
				this.MultiplicationTransformPoint,
				this.Casting,
				this.DimensionCasting,
				this.Hash
			);
		}

		double Cast(double value)
		{
			return (double)value;
		}
		#region Equality
		[Test]
		public void Equality()
		{
			Target.Double.Transform transform = null;
			Verify(this.Transform0, Is.EqualTo(this.Transform0));
			Verify(this.Transform0.Equals(this.Transform0 as object), Is.True);
			Verify(this.Transform0 == this.Transform0, Is.True);
			Verify(this.Transform0 != this.Transform1, Is.True);
			Verify(this.Transform0 == Transform3, Is.False);    
			Verify(transform == transform, Is.True);
			Verify(transform == this.Transform0, Is.False); 
		}
		#endregion
		[Test]
		public void InverseTransform1()
		{

			Kean.Math.Geometry3D.Double.Transform transform =
				new Kean.Math.Geometry3D.Double.Transform(0.035711678574190f, 0.849129305868777f, 0.933993247757551f, 0.678735154857773f, 0.757740130578333f, 0.743132468124916f, 0.392227019534168f, 0.655477890177557f, 0.171186687811562f, 0.706046088019609f, 0.031832846377421f, 0.276922984960890f);
			Kean.Math.Geometry3D.Double.Transform transformInverseCorrect = new Kean.Math.Geometry3D.Double.Transform(-1.304260393891308f, 1.703723523873863f, -0.279939209639535f, 0.639686782697661f, -1.314595978968342f, 2.216619899417434f, 0.538976631155336f, 1.130007253038916f, -2.004511083979782f, 0.751249880258891f, -1.473984978790241f, 0.682183855876876f);

			Kean.Math.Matrix.Double transformInverseMatrix1 = (Kean.Math.Matrix.Double)(double[,])transform.Inverse;
			Kean.Math.Matrix.Double transformInverseMatrix2 = (Kean.Math.Matrix.Double)(double[,])transformInverseCorrect;
			Verify(transformInverseMatrix1.Distance(transformInverseMatrix2), Is.LessThan(0.00001));
		}
		#region Arithmetic
		[Test]
		public void InverseTransform()
		{
			Target.Double.Transform transform = this.Transform0.Inverse;
			Target.Double.Transform correct = this.Transform3;
			Verify(transform.A, Is.EqualTo(correct.A).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(correct.B).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(correct.C).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(correct.D).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(correct.E).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(correct.F).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(correct.G).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(correct.H).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(correct.I).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(correct.J).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(correct.K).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(correct.L).Within(this.Precision));
		}
		[Test]
		public void MultiplicationTransformTransform()
		{
			Verify(this.Transform0 * this.Transform1, Is.EqualTo(this.Transform2));
		}
		[Test]
		public void MultiplicationTransformPoint()
		{
			Verify(this.Transform0 * this.Point0, Is.EqualTo(this.Point1));
		}
		#endregion
		[Test]
		public void CreateZeroTransform()
		{
			Target.Double.Transform transform = new Target.Double.Transform();
			Verify(transform.A, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateIdentity()
		{
			Target.Double.Transform transform = Target.Double.Transform.Identity; 
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void Rotate()
		{
			Target.Double.Transform identity = Target.Double.Transform.Identity;
			double angle = Math.Double.ToRadians(20);
			Target.Double.Transform transform = Target.Double.Transform.CreateRotationX(angle);
			transform = transform.RotateX(-angle);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void Scale()
		{
			Target.Double.Transform identity =Target.Double.Transform.Identity;
			double scale = 20;
			Target.Double.Transform transform = Target.Double.Transform.CreateScaling(scale, scale, scale);
			transform = transform.Scale(1 / scale, 1 / scale, 1 / scale);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void Translatate()
		{
			double xDelta = 40;
			double yDelta = -40;
			double zDelta = 30;
			Target.Double.Transform transform = Target.Double.Transform.CreateTranslation(xDelta, yDelta, zDelta);
			transform = transform.Translate(-xDelta, -yDelta, -zDelta);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateRotation()
		{
			double angle = Math.Double.ToRadians(20);
			Target.Double.Transform transform = Target.Double.Transform.CreateRotationX(angle);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(Math.Double.Cosinus(angle)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(Math.Double.Sinus(angle)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(Math.Double.Sinus(-angle)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(Math.Double.Cosinus(angle)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateScale()
		{
			double scale = 20;
			Target.Double.Transform transform = Target.Double.Transform.CreateScaling(scale, scale, scale);
			Verify(transform.A, Is.EqualTo(scale).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(scale).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(scale).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateTranslation()
		{
			double xDelta = 40;
			double yDelta = -40;
			double zDelta = 30;
			Target.Double.Transform transform = Target.Double.Transform.CreateTranslation(xDelta, yDelta, zDelta);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(xDelta).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(yDelta).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(zDelta).Within(this.Precision));
		}
		[Test]
		public void InverseTransform2()
		{
			Kean.Math.Geometry3D.Double.Transform transform =
				new Kean.Math.Geometry3D.Double.Transform(-0.829516518295923f, -0.207909983627822f, -0.518339449185655f, -0.176317665787488f, 0.978147963606672f, -0.110175505550793f, 0.529919264233205f, 0, -0.848048096156426f, 0, 0, 0);
			Kean.Math.Geometry3D.Double.Transform transformInverseCorrect =
				new Kean.Math.Geometry3D.Double.Transform(-0.829516518295923f, -0.176317665787488f, 0.529919264233205f, -0.207909983627822f, 0.978147963606672f, -1.15118542239879e-17f, -0.518339449185655f, -0.110175505550793f, -0.848048096156426f, 0, 0, 0);
			Kean.Math.Matrix.Double transformInverseMatrix1 = (Kean.Math.Matrix.Double)(double[,])transform.Inverse;
			Kean.Math.Matrix.Double transformInverseMatrix2 = (Kean.Math.Matrix.Double)(double[,])transformInverseCorrect;
			Verify(transformInverseMatrix1.Distance(transformInverseMatrix2), Is.LessThan(0.0000001));
		}
		[Test]
		public void InverseTransform3()
		{
			Kean.Math.Matrix.Double transformMatrix = (Kean.Math.Matrix.Double)(double[,])this.Transform0;
			Kean.Math.Matrix.Double transformInverseMatrix1 = transformMatrix.Inverse();
			Kean.Math.Matrix.Double transformInverseMatrix2 = (Kean.Math.Matrix.Double)(double[,])(this.Transform0.Inverse);
			Verify(transformInverseMatrix1.Distance(transformInverseMatrix2), Is.LessThan(1e-5f));
		}
		[Test]
		public void GetScalingX()
		{
			double scale = this.Transform0.ScalingX;
			Verify(scale, Is.EqualTo(this.Cast(3.7416575f)).Within(this.Precision));
		}
		[Test]
		public void GetScalingY()
		{
			double scale = this.Transform0.ScalingY;
			Verify(scale, Is.EqualTo(this.Cast(8.77496433f)).Within(this.Precision));
		}
		[Test]
		public void GetScalingZ()
		{
			double scale = this.Transform0.ScalingZ;
			Verify(scale, Is.EqualTo(this.Cast(13.9283886f)).Within(this.Precision));
		}
		[Test]
		public void GetScaling()
		{
			double scale = this.Transform0.Scaling;
			Verify(scale, Is.EqualTo(this.Cast(8.8150)).Within(this.Precision));
		}
		[Test]
		public void GetTranslation()
		{
			Target.Double.Size translation = this.Transform0.Translation;
			Verify(translation.Width, Is.EqualTo(this.Cast(10)).Within(this.Precision));
			Verify(translation.Height, Is.EqualTo(this.Cast(11)).Within(this.Precision));
			Verify(translation.Depth, Is.EqualTo(this.Cast(12)).Within(this.Precision));
		}

		[Test]
		public void Casting()
		{
			string value = "10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120";
			Verify(this.CastToString(this.Transform4), Is.EqualTo(value));
			Verify(this.CastFromString(value), Is.EqualTo(this.Transform4));
		}
		[Test]
		public void DimensionCasting()
		{
			Geometry2D.Double.Transform transform2D = new Geometry2D.Double.Transform(1, 2, 3, 4, 5, 6);
			Target.Double.Transform transform3D = new Target.Double.Transform(1, 2, 0, 3, 4, 0, 0, 0, 0, 5, 6, 0);
			Verify((Target.Double.Transform)transform2D, Is.EqualTo(transform3D));
			transform2D = new Geometry2D.Double.Transform(1, 2, 4, 5, 10, 11);
			transform3D = new Target.Double.Transform(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
			Verify((Geometry2D.Double.Transform)transform3D, Is.EqualTo(transform2D));
		}
		#region Hash Code
		[Test]
		public void Hash()
		{
			Verify(this.Transform0.GetHashCode(), Is.Not.EqualTo(0));
		}
		#endregion
		public void CastToArray()
		{
			double[,] values = (double[,])(Target.Double.Transform.Identity);
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++)
					Verify(values[x, y], Is.EqualTo(this.Cast(x == y ? 1 : 0)).Within(this.Precision));
		}
	}
}
