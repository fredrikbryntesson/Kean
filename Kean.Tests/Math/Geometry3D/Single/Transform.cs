// 
//  Transform.cs (generated by template)
//  
//  Author:
//       Anders Frisk <andersfrisk77@gmail.com>
//  
//  Copyright (c) 2011 Anders Frisk
// 
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
// 
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
// 
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

using System;
using NUnit.Framework;
using Target = Kean.Math.Geometry3D;
using Kean.Extension;

namespace Kean.Math.Geometry3D.Test.Single
{
    [TestFixture]
    public class Transform :
   Kean.Test.Fixture<Transform>
    {
		float Precision { get { return 1e-5f; } }
        Target.Single.Transform CastFromString(string value)
        {
            return (Kean.Math.Geometry3D.Single.Transform)value;
        }
        string CastToString(Kean.Math.Geometry3D.Single.Transform value)
        {
            return (string)value;
        }
		    Target.Single.Transform Transform0 = new Kean.Math.Geometry3D.Single.Transform(-1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
			Target.Single.Transform Transform1 = new Kean.Math.Geometry3D.Single.Transform(-1, 2, 3, 4, 5, 6, 7, 8, -5, 10, 11, 12);
			Target.Single.Transform Transform2 = new Kean.Math.Geometry3D.Single.Transform(30, 32, 36, 58, 81, 96, -10, 14, 24, 128, 182, 216);
			Target.Single.Transform Transform3 = new Kean.Math.Geometry3D.Single.Transform(-0.5f, 1, -0.5f, 1, -5, 3, -0.5f, 3.66666666666666f, -2.16666666666667f, 0, 1, -2);
			Target.Single.Transform Transform4 = new Target.Single.Transform(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120);	
		    Target.Single.Point Point0 = new Kean.Math.Geometry3D.Single.Point(34, 10, 30);
			Target.Single.Point Point1 = new Kean.Math.Geometry3D.Single.Point(226, 369, 444);
        protected override void Run()
        {

            this.Run(
                this.InverseTransform1,
                this.InverseTransform2,
                this.InverseTransform3,
			    this.Equality,
				this.CreateZeroTransform,
				this.CreateIdentity,
				this.CreateRotation,
				this.CreateScale,
				this.CreateTranslation,
				this.Rotatate,
				this.Scale,
				this.Translatate,
				this.InverseTransform,
				this.MultiplicationTransformTransform,
				this.MultiplicationTransformPoint,
				this.GetTranslation,
				this.GetScalingX,
				this.GetScalingY,
				this.GetScalingZ,
				this.GetScaling,
				this.CastToArray,
				this.MultiplicationTransformTransform,
				this.MultiplicationTransformPoint,
				this.Casting,
				this.Hash
            );
        }

        float Cast(double value)
        {
            return (float)value;
        }
		#region Equality
		[Test]
		public void Equality()
		{
			Target.Single.Transform transform = null;
			Verify(this.Transform0, Is.EqualTo(this.Transform0));
			Verify(this.Transform0.Equals(this.Transform0 as object), Is.True);
			Verify(this.Transform0 == this.Transform0, Is.True);
			Verify(this.Transform0 != this.Transform1, Is.True);
			Verify(this.Transform0 == Transform3, Is.False);    
			Verify(transform == transform, Is.True);
		    Verify(transform == this.Transform0, Is.False); 
		}
		#endregion
        [Test]
        public void InverseTransform1()
        {

            Kean.Math.Geometry3D.Single.Transform transform =
                new Kean.Math.Geometry3D.Single.Transform(0.035711678574190f, 0.849129305868777f, 0.933993247757551f, 0.678735154857773f, 0.757740130578333f, 0.743132468124916f, 0.392227019534168f, 0.655477890177557f, 0.171186687811562f, 0.706046088019609f, 0.031832846377421f, 0.276922984960890f);
            Kean.Math.Geometry3D.Single.Transform transformInverseCorrect = new Kean.Math.Geometry3D.Single.Transform(-1.304260393891308f, 1.703723523873863f, -0.279939209639535f, 0.639686782697661f, -1.314595978968342f, 2.216619899417434f, 0.538976631155336f, 1.130007253038916f, -2.004511083979782f, 0.751249880258891f, -1.473984978790241f, 0.682183855876876f);

            Kean.Math.Matrix.Single transformInverseMatrix1 = (Kean.Math.Matrix.Single)(float[,])transform.Inverse;
            Kean.Math.Matrix.Single transformInverseMatrix2 = (Kean.Math.Matrix.Single)(float[,])transformInverseCorrect;
            Verify(transformInverseMatrix1.Distance(transformInverseMatrix2), Is.LessThan(0.00001));
        }
		#region Arithmetic
		[Test]
		public void InverseTransform()
		{
			Target.Single.Transform transform = this.Transform0.Inverse;
			Target.Single.Transform correct = this.Transform3;
			Verify(transform.A, Is.EqualTo(correct.A).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(correct.B).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(correct.C).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(correct.D).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(correct.E).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(correct.F).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(correct.G).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(correct.H).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(correct.I).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(correct.J).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(correct.K).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(correct.L).Within(this.Precision));
		}
		[Test]
		public void MultiplicationTransformTransform()
		{
			Verify(this.Transform0 * this.Transform1, Is.EqualTo(this.Transform2));
		}
		[Test]
		public void MultiplicationTransformPoint()
		{
			Verify(this.Transform0 * this.Point0, Is.EqualTo(this.Point1));
		}
		#endregion
		[Test]
		public void CreateZeroTransform()
		{
			Target.Single.Transform transform = new Target.Single.Transform();
			Verify(transform.A, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateIdentity()
		{
			Target.Single.Transform transform = Target.Single.Transform.Identity; 
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void Rotatate()
		{
			Target.Single.Transform identity = Target.Single.Transform.Identity;
			float angle = Math.Single.ToRadians(20);
			Target.Single.Transform transform = Target.Single.Transform.CreateRotationX(angle);
			transform = transform.RotateX(-angle);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void Scale()
		{
			Target.Single.Transform identity =Target.Single.Transform.Identity;
			float scale = 20;
			Target.Single.Transform transform = Target.Single.Transform.CreateScaling(scale, scale, scale);
			transform = transform.Scale(1 / scale, 1 / scale, 1 / scale);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void Translatate()
		{
			float xDelta = 40;
			float yDelta = -40;
			float zDelta = 30;
			Target.Single.Transform transform = Target.Single.Transform.CreateTranslation(xDelta, yDelta, zDelta);
			transform = transform.Translate(-xDelta, -yDelta, -zDelta);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateRotation()
		{
			float angle = Math.Single.ToRadians(20);
			Target.Single.Transform transform = Target.Single.Transform.CreateRotationX(angle);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(Math.Single.Cosinus(angle)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(Math.Single.Sinus(angle)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(Math.Single.Sinus(-angle)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(Math.Single.Cosinus(angle)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateScale()
		{
			float scale = 20;
			Target.Single.Transform transform = Target.Single.Transform.CreateScaling(scale, scale, scale);
			Verify(transform.A, Is.EqualTo(scale).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(scale).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(scale).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(this.Cast(0)).Within(this.Precision));
		}
		[Test]
		public void CreateTranslation()
		{
			float xDelta = 40;
			float yDelta = -40;
			float zDelta = 30;
			Target.Single.Transform transform = Target.Single.Transform.CreateTranslation(xDelta, yDelta, zDelta);
			Verify(transform.A, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.B, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.C, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.D, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.E, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.F, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.G, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.H, Is.EqualTo(this.Cast(0)).Within(this.Precision));
			Verify(transform.I, Is.EqualTo(this.Cast(1)).Within(this.Precision));
			Verify(transform.J, Is.EqualTo(xDelta).Within(this.Precision));
			Verify(transform.K, Is.EqualTo(yDelta).Within(this.Precision));
			Verify(transform.L, Is.EqualTo(zDelta).Within(this.Precision));
		}
        [Test]
        public void InverseTransform2()
        {
            Kean.Math.Geometry3D.Single.Transform transform =
                new Kean.Math.Geometry3D.Single.Transform(-0.829516518295923f, -0.207909983627822f, -0.518339449185655f, -0.176317665787488f, 0.978147963606672f, -0.110175505550793f, 0.529919264233205f, 0, -0.848048096156426f, 0, 0, 0);
            Kean.Math.Geometry3D.Single.Transform transformInverseCorrect =
                new Kean.Math.Geometry3D.Single.Transform(-0.829516518295923f, -0.176317665787488f, 0.529919264233205f, -0.207909983627822f, 0.978147963606672f, -1.15118542239879e-17f, -0.518339449185655f, -0.110175505550793f, -0.848048096156426f, 0, 0, 0);
            Kean.Math.Matrix.Single transformInverseMatrix1 = (Kean.Math.Matrix.Single)(float[,])transform.Inverse;
            Kean.Math.Matrix.Single transformInverseMatrix2 = (Kean.Math.Matrix.Single)(float[,])transformInverseCorrect;
            Verify(transformInverseMatrix1.Distance(transformInverseMatrix2), Is.LessThan(0.0000001));
        }
        [Test]
        public void InverseTransform3()
        {
            Kean.Math.Matrix.Single transformMatrix = (Kean.Math.Matrix.Single)(float[,])this.Transform0;
            Kean.Math.Matrix.Single transformInverseMatrix1 = transformMatrix.Inverse();
            Kean.Math.Matrix.Single transformInverseMatrix2 = (Kean.Math.Matrix.Single)(float[,])(this.Transform0.Inverse);
            Verify(transformInverseMatrix1.Distance(transformInverseMatrix2), Is.LessThan(1e-5f));
        }
		[Test]
		public void GetScalingX()
		{
			float scale = this.Transform0.ScalingX;
			Verify(scale, Is.EqualTo(this.Cast(3.7416575f)).Within(this.Precision));
		}
		[Test]
		public void GetScalingY()
		{
			float scale = this.Transform0.ScalingY;
			Verify(scale, Is.EqualTo(this.Cast(8.77496433f)).Within(this.Precision));
		}
		[Test]
		public void GetScalingZ()
		{
			float scale = this.Transform0.ScalingZ;
			Verify(scale, Is.EqualTo(this.Cast(13.9283886f)).Within(this.Precision));
		}
		[Test]
		public void GetScaling()
		{
			float scale = this.Transform0.Scaling;
			Verify(scale, Is.EqualTo(this.Cast(8.8150)).Within(this.Precision));
		}
		[Test]
		public void GetTranslation()
		{
			Target.Single.Size translation = this.Transform0.Translation;
			Verify(translation.Width, Is.EqualTo(this.Cast(10)).Within(this.Precision));
			Verify(translation.Height, Is.EqualTo(this.Cast(11)).Within(this.Precision));
			Verify(translation.Depth, Is.EqualTo(this.Cast(12)).Within(this.Precision));
		}

		[Test]
		public void Casting()
		{
			string value = "10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120";
			Verify(this.CastToString(this.Transform4), Is.EqualTo(value));
			Verify(this.CastFromString(value), Is.EqualTo(this.Transform4));
		}
		
		#region Hash Code
		[Test]
		public void Hash()
		{
			Verify(this.Transform0.GetHashCode(), Is.Not.EqualTo(0));
		}
		#endregion
		public void CastToArray()
		{
			float[,] values = (float[,])(Target.Single.Transform.Identity);
			for (int x = 0; x < 4; x++)
				for (int y = 0; y < 4; y++)
					Verify(values[x, y], Is.EqualTo(this.Cast(x == y ? 1 : 0)).Within(this.Precision));
		}

      
    }
}
