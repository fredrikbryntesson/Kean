<#@ template language="C#v3.5" hostspecific="True" #>
<#
    GenerateFile("Single", "float");
    SaveOutput("Single.cs");  
    GenerateFile("Double", "double");
    SaveOutput("Double.cs");  
#>
<#+
  void SaveOutput(string outputFileName)
  {
      string templateDirectory = System.IO.Path.GetDirectoryName(Host.TemplateFile);
      string outputFilePath = System.IO.Path.Combine(templateDirectory, outputFileName);
      System.IO.File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString()); 
      this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
  }
#>
<#+
    void GenerateFile(string @class, string @value)
    {
#>
// 
//  <#= @class #>.cs (generated by template)
//  
//  Author:
//       Anders Frisk <andersfrisk77@gmail.com>
//  
//  Copyright (c) 2011 Anders Frisk
// 
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
// 
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
// 
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
using System;
using Geometry2D = Kean.Math.Geometry2D;
using Kean.Extension;
namespace Kean.Math.Matrix
{
    public class <#= @class #> :
        System.IEquatable<<#= @class #>>
    {
        #region Properties
        Geometry2D.Integer.Size dimensions;
        public Geometry2D.Integer.Size Dimensions { get { return this.dimensions; } private set { this.dimensions = value; } }
        // Matrix elements are supposed to be in column major order 
        /// <summary>
        /// True if the matrix is a square matrix.
        /// </summary>
        public bool IsSquare { get { return this.Dimensions.Width == this.Dimensions.Height; } }
        /// <summary>
        /// Minimum of maxtrix dimensions.
        /// </summary>
        public int Order { get { return Kean.Math.Integer.Minimum(this.Dimensions.Width, this.Dimensions.Height); } }
        /// <summary>
        /// Frobenius norm of matrix
        /// </summary>
        public <#= @value #> Norm { get { return Kean.Math.<#= @class #>.SquareRoot(this.ScalarProduct(this)); } }
        public <#= @value #> NormInfinity
        {
            get
            {
                <#= @value #> result = 0;
                for (int x = 0; x < this.Dimensions.Width; x++)
                    for (int y = 0; y < this.Dimensions.Height; y++)
                        result = Kean.Math.<#= @class #>.Maximum(result, Kean.Math.<#= @class #>.Absolute(this[x, y]));
                return result;
            }
        }
        /// <summary>
        /// Return true if the current matrix is a diagonal matrix within the specified tolerance.
        /// </summary>
        /// <param name="tolerance">Tolerance used to check zero elements outside the diagonal.</param>
        /// <returns>True is the matrix is a diagonal matrix within the given tolerance.</returns>
        public bool IsDiagonal(float tolerance)
        {
            bool result = true;
            for (int x = 0; x < this.Dimensions.Width; x++)
                for (int y = 0; y < this.Dimensions.Height; y++)
                {
                    if (x != y && Kean.Math.<#= @class #>.Absolute(this[x, y]) > tolerance)
                    {
                        result = false;
                        x = this.Dimensions.Width;
                        break;
                    }
                }
            return result;
        }
        /// <summary>
        /// Trace of the current matrix.
        /// </summary>
        /// <returns>Return the trace of the current matrix.</returns>
        public <#= @value #> Trace
        {
            get
            {
                <#= @value #> result = 0;
                int order = this.Order;
                for (int i = 0; i < order; i++)
                    result += this[i, i];
                return result;
            }
        }
        public <#= @value #> Determinant
        {
            get
            {
                <#= @class #>[] lup = this.LupDecomposition();
                <#= @value #> result = 1;
                for (int position = 0; position < lup[1].Dimensions.Height; position++)
                    result *= lup[1][position, position];
                return result * lup[2].Sign();
            }
        }
        /// <summary>
        /// Get or set an element in a matrix at position(x,y).
        /// </summary>
        /// <param name="x">Column number of a matrix.</param>
        /// <param name="y">Row number of a matrix.</param>
        /// <returns></returns>
        public <#= @value #> this[int x, int y]
        {
            get { return this.elements[this.Index(x, y)]; }
            set { this.elements[this.Index(x, y)] = value; }
        }
        int Index(int x, int y)
        {
            return x * this.Dimensions.Height + y; // Column major order 
            // Use Y * this.Dimensions.Width + X for row major order
        }
        #endregion
        #region Private Fields
        <#= @value #>[] elements;
        #endregion
        #region Constructors
        public <#= @class #>() : this(0) { }
        public <#= @class #>(int order) : this(order, order) { }
        public <#= @class #>(int width, int height) : this(new Geometry2D.Integer.Size(width, height)) { }
        public <#= @class #>(Geometry2D.Integer.Size dimensions) : this(dimensions, new <#= @value #>[dimensions.Area]) { }
        public <#= @class #>(int width, int height, <#= @value #>[] elements) : this(new Geometry2D.Integer.Size(width, height), elements) { }
        public <#= @class #>(Geometry2D.Integer.Size dimensions, <#= @value #>[] elements)
        {
            this.Dimensions = dimensions;
            int minimum = Kean.Math.Integer.Minimum(elements.Length, this.Dimensions.Area);
            this.elements = new <#= @value #>[this.Dimensions.Area];
            Array.Copy(elements, 0, this.elements, 0, minimum);
        }
        #endregion
        #region Matrix Geometry
        /// <summary>
        /// Distance induced by the Frobenius norm.
        /// </summary>
        /// <param name="other">Other matrix.</param>
        /// <returns>Distance between current and other matrix.</returns>
        public <#= @value #> Distance(<#= @class #> other)
        {
            return (this - other).Norm;
        }
        public <#= @value #> ScalarProduct(<#= @class #> other)
        {
            if (this.Dimensions != other.Dimensions)
                new Exception.InvalidDimensions();
            <#= @value #> result = 0;
            for (int x = 0; x < this.Dimensions.Width; x++)
                for (int y = 0; y < this.Dimensions.Height; y++)
                    result += this[x, y] * other[x, y];
            return result;
        }
        #endregion
        #region Static Arithmetic: Matrix and Scalar Operators
        /// <summary>
        /// Addition of matrices.
        /// </summary>
        /// <param name="left">Left matrix in the addition.</param>
        /// <param name="right">Right matrix in the addition.</param>
        /// <returns>Sum of left and right matrices.</returns>
        public static <#= @class #> operator +(<#= @class #> left, <#= @class #> right)
        {
            if (left.Dimensions != right.Dimensions)
                new Exception.InvalidDimensions();
            <#= @class #> result = new <#= @class #>(left.Dimensions);
            for (int i = 0; i < result.elements.Length; i++)
                result.elements[i] = left.elements[i] + right.elements[i];
            return result;
        }
        /// <summary>
        /// Multiplication of matrices.
        /// </summary>
        /// <param name="left">Left matrix in the multiplication.</param>
        /// <param name="right">Right matrix in the multiplication.</param>
        /// <returns>Product of left and right matrices.</returns>
        public static <#= @class #> operator *(<#= @class #> left, <#= @class #> right)
        {
            if (left.Dimensions.Width != right.Dimensions.Height)
                new Exception.InvalidDimensions();
            <#= @class #> result = new <#= @class #>(right.Dimensions.Width, left.Dimensions.Height);
            for (int x = 0; x < right.Dimensions.Width; x++)
                for (int y = 0; y < left.Dimensions.Height; y++)
                    for (int z = 0; z < left.Dimensions.Width; z++)
                        result[x, y] = result[x, y] + left[z, y] * right[x, z];
            return result;
        }
        /// Difference between matrices.
        /// </summary>
        /// <param name="left">Left matrix in the differerence.</param>
        /// <param name="right">Right matrix in the differerence.</param>
        /// <returns>Difference of left and right matrices.</returns>
        public static <#= @class #> operator -(<#= @class #> left, <#= @class #> right)
        {
            if (left.Dimensions != right.Dimensions)
                new Exception.InvalidDimensions();
            <#= @class #> result = new <#= @class #>(left.Dimensions);
            for (int i = 0; i < result.elements.Length; i++)
                result.elements[i] = left.elements[i] - right.elements[i];
            return result;

        }
        /// <summary>
        /// Multiplication between scalar and matrix.
        /// </summary>
        /// <param name="left">Left scalar in the multiplication.</param>
        /// <param name="right">Right matrix in the multiplication.</param>
        /// <returns>Product of scalar and matrix.</returns>
        public static <#= @class #> operator *(<#= @value #> left, <#= @class #> right)
        {
            <#= @class #> result = new <#= @class #>(right.Dimensions);
            for (int i = 0; i < result.elements.Length; i++)
                result.elements[i] = left * right.elements[i];
            return result;
        }
        /// <summary>
        /// Multiplication between scalar and matrix.
        /// </summary>
        /// <param name="left">Left matrix in the multiplication.</param>
        /// <param name="right">Right scalar in the multiplication.</param>
        /// <returns>Product of matrix and  scalar.</returns>
        public static <#= @class #> operator *(<#= @class #> left, <#= @value #> right)
        {
            return right * left;
        }
        /// <summary>
        /// Division between scalar and matrix.
        /// </summary>
        /// <param name="left">Left matrix in the multiplication.</param>
        /// <param name="right">Right scalar in the multiplication.</param>
        /// <returns>Quotient between matrix and scalar.</returns>
        public static <#= @class #> operator /(<#= @class #> left, <#= @value #> right)
        {
            return left * (1 / right);
        }
        /// <summary>
        /// Negation of a matrix.
        /// </summary>
        /// <param name="value">Matrix to be negated.</param>
        /// <returns>Negated matrix.</returns>
        public static <#= @class #> operator -(<#= @class #> value)
        {
            return (-1) * value;
        }
        #endregion
        #region Matrix Methods
        /// <summary>
        /// Tranpose matrix. Creates a new matrix being the transpose of the current matrix.
        /// </summary>
        /// <returns>Return current matrix tranposed.</returns>
        public <#= @class #> Transpose()
        {
            <#= @class #> result = new <#= @class #>(this.Dimensions.Height, this.Dimensions.Width);
            for (int x = 0; x < result.Dimensions.Width; x++)
                for (int y = 0; y < result.Dimensions.Height; y++)
                    result[x, y] = this[y, x];
            return result;
        }
        /// <summary>
        /// Adjoint matrix. Creates a new matrix which is the adjoint of the current matrix.
        /// </summary>
        /// <returns>Adjoint of current matrix.</returns>
        public <#= @class #> Adjoint()
        {
            <#= @class #> result = new <#= @class #>(this.Dimensions.Width, this.Dimensions.Height);
            for (int x = 0; x < result.Dimensions.Width; x++)
                for (int y = 0; y < result.Dimensions.Height; y++)
                    result[x, y] = Kean.Math.<#= @class #>.Power(-1, x + 1 + y + 1) * this.Minor(y, x).Determinant;
            return result;

        }
        /// <summary>
        /// Minor of the current matrix.
        /// </summary>
        /// <param name="x">Column position in the matrix.</param>
        /// <param name="y">Row position in the matrix.</param>
        /// <returns>Return the minor of a matrix at position (x,y).</returns>
        public <#= @class #> Minor(int x, int y)
        {
            if (this.Dimensions.Width < 1 || this.Dimensions.Height < 1)
                new Exception.InvalidDimensions();
            <#= @class #> result = new <#= @class #>(this.Dimensions.Width - 1, this.Dimensions.Height - 1);
            for (int xx = 0; xx < x; xx++)
            {
                for (int yy = 0; yy < y; yy++)
                    result[xx, yy] = this[xx, yy];
                for (int yy = y + 1; yy < this.Dimensions.Height; yy++)
                    result[xx, yy - 1] = this[xx, yy];
            }
            for (int xx = x + 1; xx < this.Dimensions.Width; xx++)
            {
                for (int yy = 0; yy < y; yy++)
                    result[xx - 1, yy] = this[xx, yy];
                for (int yy = y + 1; yy < this.Dimensions.Height; yy++)
                    result[xx - 1, yy - 1] = this[xx, yy];
            }
            return result;
        }
        /// <summary>
        /// Platformct the submatrix being the rectangular part of current matrix with top left corner (x,y).
        /// </summary>
        /// <param name="left">Column position.</param>
        /// <param name="top">Row position.</param>
        /// <returns>Return the extract submatrix with top left corner (x,y).</returns>
        public <#= @class #> Extract(int left, int top)
        {
            return this.Extract(left, this.Dimensions.Width, top, this.Dimensions.Height);
        }
        public <#= @class #> Extract(int left, int right, int top, int bottom)
        {
            if (
                left < 0 || left > this.Dimensions.Width ||
                right < 0 || right > this.Dimensions.Width ||
                top < 0 || top > this.Dimensions.Height ||
                bottom < 0 || bottom > this.Dimensions.Height)
                throw new Exception.InvalidDimensions();
            <#= @class #> result = new <#= @class #>(right - left, bottom - top);
            for (int x = left; x < right; x++)
                for (int y = top; y < bottom; y++)
                    result[x - left, y - top] = this[x, y];
            return result;
        }
        /// <summary>
        /// Paste a submatrix into a copy of the current matrix. The submatrix is pasted a position top left corner
        /// (x,y).
        /// </summary>
        /// <param name="x">Column position.</param>
        /// <param name="y">Row position.</param>
        /// <param name="submatrix">Matrix to be pasted into current matrix.</param>
        /// <returns>Return new matrix with submatrix pasted.</returns>
        public <#= @class #> Paste(int left, int top, <#= @class #> submatrix)
        {
            if (
                left < 0 || left > this.Dimensions.Width ||
                top < 0 || top > this.Dimensions.Height)
                throw new Exception.InvalidDimensions();
            <#= @class #> result = this.Copy();
            for (int x = 0; x < submatrix.Dimensions.Width; x++)
                for (int y = 0; y < submatrix.Dimensions.Height; y++)
                    result[x + left, y + top] = submatrix[x, y];
            return result;
        }
        /// <summary>
        /// Paste a submatrix into a copy of the current matrix. The submatrix is pasted a position top left corner (x,y).
        /// This method does not create a new matrix but instead keeps the current matrix.
        /// </summary>
        /// <param name="left">Column position.</param>
        /// <param name="top">Row position.</param>
        /// <param name="submatrix">Matrix to paste into the current matrix.</param>
        public void Set(int left, int top, <#= @class #> submatrix)
        {
            if (
                left < 0 || left > this.Dimensions.Width ||
                top < 0 || top > this.Dimensions.Height)
                throw new Exception.InvalidDimensions();
            for (int x = 0; x < submatrix.Dimensions.Width; x++)
                for (int y = 0; y < submatrix.Dimensions.Height; y++)
                    this[x + left, y + top] = submatrix[x, y];
        }
        /// <summary>
        /// Sets a region in a matrix to zero.
        /// </summary>
        /// <param name="left"></param>
        /// <param name="right"></param>
        /// <param name="top"></param>
        /// <param name="bottom"></param>
        public void Clear(int left, int right, int top, int bottom)
        {
            if (
                left < 0 || left > this.Dimensions.Width ||
                right < 0 || right > this.Dimensions.Width ||
                top < 0 || top > this.Dimensions.Height ||
                bottom < 0 || bottom > this.Dimensions.Height)
                throw new Exception.InvalidDimensions();
            for (int x = left; x < right; x++)
                for (int y = top; y < bottom; y++)
                    this[x, y] = 0;
        }
        public void Clear()
        {
            for (int x = 0; x < this.Dimensions.Width; x++)
                for (int y = 0; y < this.Dimensions.Height; y++)
                    this[x, y] = 0;
        }
        /// <summary>
        /// Creates a copy of the current matrix.
        /// </summary>
        /// <returns>Return a copy of the current matrix.</returns>
        public <#= @class #> Copy()
        {
            <#= @class #> result = new <#= @class #>(this.Dimensions);
            Array.Copy(this.elements, result.elements, this.elements.Length);
            return result;
        }
        public <#= @class #> Kronecker(<#= @class #> other)
        {
            <#= @class #>[,] blocks = new <#= @class #>[this.Dimensions.Width, this.Dimensions.Height];
            for (int x = 0; x < this.Dimensions.Width; x++)
                for (int y = 0; y < this.Dimensions.Height; y++)
                    blocks[x, y] = this[x, y] * other;
            return <#= @class #>.Block(blocks);
        }
        #endregion
        #region Cholesky Methods
        /// <summary>
        /// Gaxby (Algorithm 4.2.1 p.144) Cholesky factorization of positive symmetric matrix. A = C * C'.  The matrix C is lower triangular.
        /// </summary>
        /// <returns> Cholesky factorization matix.</returns>
        public <#= @class #> Cholesky()
        {
            if (!this.IsSquare)
                new Exception.InvalidDimensions();
            int order = this.Dimensions.Width;
            <#= @class #> result = this.Copy();
            try
            {
                for (int j = 0; j < order; j++)
                {
                    if (j > 0)
                        result.Set(j, j, result.Extract(j, j + 1, j, order) - result.Extract(0, j, j, order) * result.Extract(0, j, j, j + 1).Transpose());
                    <#= @value #> value = result[j, j];
                    if (value <= 0)
                        throw new Exception.NonPositive();
                    result.Set(j, j, result.Extract(j, j + 1, j, order) / Kean.Math.<#= @class #>.SquareRoot(value));
                }
                for (int y = 0; y < order; y++)
                    for (int x = y + 1; x < order; x++)
                        result[x, y] = 0;
            }
            catch (Kean.Error.Exception e)
            {
                result = null;
            }
            return result;
        }
        /// <summary>
        /// Cholesky least square solver A * x = y. See http://en.wikipedia.org/wiki/Cholesky_decomposition
        /// The current matrix determines the matrix A above.
        /// </summary>
        /// <param name="y">The right hand column y vector of the equation system.</param>
        /// <returns>Return the least square solution to the system,</returns>
        public <#= @class #> SolveCholesky(<#= @class #> y)
        {
            <#= @class #> result = null;
            try
            {
                if (this.Dimensions.Height < this.Dimensions.Width)
                {
                    // Least norm
                    <#= @class #> transpose = this.Transpose();
                    <#= @class #> lower = (this * transpose).Cholesky();
                    <#= @class #> z = y.ForwardSubstitution(lower);
                    z = z.BackwardSubstitution(lower.Transpose());
                    result = transpose * z;
                }
                else
                {
                    // Standard
                    <#= @class #> transpose = this.Transpose();
                    <#= @class #> lower = (transpose * this).Cholesky();
                    <#= @class #> z = (transpose * y).ForwardSubstitution(lower);
                    result = z.BackwardSubstitution(lower.Transpose());
                }
            }
            catch (Kean.Error.Exception e)
            {
            }
            return result;
        }
        #endregion
        #region QR methods
        /// <summary>
        /// QR least square solver A * x = y. See http://en.wikipedia.org/wiki/QR_decomposition
        /// The current matrix determines the matrix A above.
        /// </summary>
        /// <param name="y">The right hand column y vector of the equation system.</param>
        /// <returns>Return the least square solution to the system,</returns>
        public <#= @class #> SolveQr(<#= @class #> y)
        {
            <#= @class #> result = null;
            try
            {
                if (this.Dimensions.Height < this.Dimensions.Width)
                {
                    // Least norm
                    <#= @class #> transpose = this.Transpose();
                    <#= @class #>[] qr = transpose.QRFactorization();
                    <#= @class #> q = qr[0].Extract(0, transpose.Dimensions.Width, 0, transpose.Dimensions.Height);
                    <#= @class #> r = qr[1].Extract(0, transpose.Dimensions.Width, 0, transpose.Dimensions.Width);
                    <#= @class #> z = y.ForwardSubstitution(r.Transpose());
                    result = q * z;
                }
                else
                {
                    // Standard
                    <#= @class #>[] qr = this.QRFactorization();
                    <#= @class #> q = qr[0].Extract(0, this.Dimensions.Width, 0, this.Dimensions.Height);
                    <#= @class #> r = qr[1].Extract(0, this.Dimensions.Width, 0, this.Dimensions.Width);
                    result = (q.Transpose() * y).BackwardSubstitution(r);
                }
            }
            catch (Kean.Error.Exception e)
            {
            }
            return result;
        }
        /// <summary>
        /// QR factorizion of the current matrix. See http://en.wikipedia.org/wiki/QR_decomposition
        /// Recall that A = QR.
        /// </summary>
        /// <returns>Return the QR-factorization array with Q = [0] and R = [1]. </returns>
        public <#= @class #>[] QRFactorization()
        {
            int order = this.Dimensions.Height;
            int iterations = Kean.Math.Integer.Minimum(this.Dimensions.Height - 1, this.Dimensions.Width);
            <#= @class #> r = this;
            <#= @class #> q = <#= @class #>.Identity(order);
            for (int i = 0; i < iterations; i++)
            {
                <#= @class #> x = r.Extract(i, i + 1, i, r.Dimensions.Height);
                <#= @class #> y = (Kean.Math.<#= @class #>.Sign(x[0, 0]) * x.Norm) * <#= @class #>.Basis(r.Dimensions.Height - i, 0);
                <#= @class #> qi = <#= @class #>.Identity(order).Paste(i, i, <#= @class #>.HouseHolder(x, y));
                r = qi * r;
                q *= qi.Transpose();
            }
            return new <#= @class #>[] { q, r };
        }
        // Contruct Householder transform from two  column vectors of same length and norm.
        static <#= @class #> HouseHolder(<#= @class #> x, <#= @class #> y)
        {
            if (x.Dimensions.Width != y.Dimensions.Width && x.Dimensions.Width != 1 && x.Dimensions.Height != y.Dimensions.Height)
                throw new Exception.InvalidDimensions();
            int length = x.Dimensions.Height;
            <#= @class #> w = x - y;
            <#= @value #> norm = w.Norm;
            <#= @class #> result = <#= @class #>.Identity(length);
            if (norm != 0)
            {
                w /= norm;
                result -= 2 * w * w.Transpose();
            }
            return result;
        }
        /// <summary>
        /// Eigenvalue decomposition of a symmetric square matrix.
        /// a = u * d * u.Transpose();
        /// </summary>
        /// <returns>Array of matrices {u, d}.</returns>
        public <#= @class #>[] Eigenvalues()
        {
            if (!this.IsSquare)
                new Exception.InvalidDimensions();
            int order = this.Dimensions.Width;
            <#= @value #> tolerance = (<#= @value #>)1e-5;
            int iterations = 100;
            <#= @class #> u = this;
            <#= @class #> q = <#= @class #>.Identity(order);
            int i = 0;
            <#= @value #> error = <#= @value #>.MaxValue;
            while (error > tolerance && i < iterations)
            {
                <#= @class #>[] qr = u.QRFactorization();
                u = qr[0].Transpose() * u * qr[0];
                q *= qr[0];
                error = 0;
                for (int j = 0; j < order; j++)
                    for (int k = 0; k < order; k++)
                        error += j != k ? Kean.Math.<#= @class #>.Absolute(u[j, k]) : 0;
                i++;
            }
            return new <#= @class #>[] { q, u };
        }
        #endregion
        #region Diagonalization
        /// <summary>
        /// See Algorithm 5.4.2 (Householder Bidiagonalization).
        /// Computation of the Householder bidiagonalization of current matrix. Note height >= width.
        /// The method return {u, y, v}, where u,v are orthogonal matrices such that u' * current * v = y,
        /// where y is a bidiagonal matrix with a posssibly nonzero superdiagonal.
        /// </summary>
        /// <returns>Array of matrices {u,y,v}.</returns>
        <#= @class #>[] BiDiagonalization()
        {
            <#= @class #>[] result;
            <#= @class #> b = this.Copy();
            int n = b.Dimensions.Width;
            int m = b.Dimensions.Height;
            <#= @class #>[] leftHouseholder = new <#= @class #>[n];
            <#= @class #>[] rightHouseholder = null;
            if (n - 2 >= 1)
                rightHouseholder = new <#= @class #>[n - 2];

            for (int j = 0; j < n; j++)
            {
                Tuple<<#= @class #>, <#= @value #>> leftHousePair = b.Extract(j, j + 1, j, m).House();
                <#= @class #> leftHouseMultiplier = <#= @class #>.Identity(m - j) - leftHousePair.Item2 * leftHousePair.Item1 * leftHousePair.Item1.Transpose();
                leftHouseholder[j] = leftHouseMultiplier;
                b.Set(j, j, leftHouseMultiplier * b.Extract(j, j));
                if (j < n - 2)
                {
                    Tuple<<#= @class #>, <#= @value #>> rightHousePair = b.Extract(j + 1, n, j, j + 1).Transpose().House();
                    <#= @class #> rightHouseMultiplier = <#= @class #>.Identity(n - j - 1) - rightHousePair.Item2 * rightHousePair.Item1 * rightHousePair.Item1.Transpose();
                    rightHouseholder[j] = rightHouseMultiplier;
                    b.Set(j + 1, j, b.Extract(j + 1, j) * rightHouseMultiplier);
                }
            }
            <#= @class #> u = <#= @class #>.Identity(m);
            for (int j = n - 1; j >= 0; j--)
                u.Set(j, j, leftHouseholder[j] * u.Extract(j, j));
            <#= @class #> v = <#= @class #>.Identity(n);
            for (int j = n - 3; j >= 0; j--)
                v.Set(j + 1, j + 1, rightHouseholder[j] * v.Extract(j + 1, j + 1));
            result = new <#= @class #>[] { u, b, v };
            return result;

        }
        /// <summary>
        /// See Algorithm 5.1.1 (Householder Vector).
        /// </summary>
        /// <returns></returns>
        Tuple<<#= @class #>, <#= @value #>> House()
        {
            Tuple<<#= @class #>, <#= @value #>> result;
            int n = this.Dimensions.Height;
            <#= @class #> tail = this.Extract(0, 1, 1, n);
            <#= @value #> sigma = (tail.Transpose() * tail)[0, 0];
            <#= @class #> nu = new <#= @class #>(1, n);
            nu[0, 0] = 1;
            nu.Set(0, 1, tail);
            <#= @value #> beta = 0;
            if (sigma != 0)
            {
                <#= @value #> x00 = this[0, 0];
                <#= @value #> mu = Kean.Math.<#= @class #>.SquareRoot(Kean.Math.<#= @class #>.Squared(x00) + sigma);
                if (x00 <= 0)
                    nu[0, 0] = x00 - mu;
                else
                    nu[0, 0] = -sigma / (x00 + mu);
                <#= @value #> nu00Squared = Kean.Math.<#= @class #>.Squared(nu[0, 0]);
                beta = 2 * nu00Squared / (sigma + nu00Squared);
                nu /= nu[0, 0];
            }
            result = Tuple.Create<<#= @class #>, <#= @value #>>(nu, beta);
            return result;
        }
        #endregion
        #region Svd Methods
        /// <summary>
        /// Svd least square solver A * x = y. See http://en.wikipedia.org/wiki/Linear_least_squares_(mathematics).
        /// The current matrix determines the matrix A above.
        /// </summary>
        /// <param name="y">The right hand column y vector of the equation system.</param>
        /// <returns>Return the least square solution to the system,</returns>
        public <#= @class #> SolveSvd(<#= @class #> b)
        {
            <#= @class #> result;
            <#= @class #>[] usv = this.Svd();
            <#= @class #> u = usv[0];
            <#= @class #> s = usv[1];
            <#= @class #> v = usv[2];
            <#= @class #> sPlus = new <#= @class #>(s.Dimensions.Width, s.Dimensions.Height);
            int order = s.Order;
            for (int i = 0; i < order; i++)
            {
                <#= @value #> value = s[i, i];
                if (value != 0)
                    sPlus[i, i] = 1 / value;
            }
            // Least square solution and minimum norm solution
            if (this.Dimensions.Height >= this.Dimensions.Width)
                result = v * sPlus * u.Transpose() * b;
            else
            {
                <#= @class #> d = new <#= @class #>(1, this.Dimensions.Width).Paste(0, 0, u.Transpose() * b);

                for (int i = 0; i < order; i++)
                    d[0, i] *= sPlus[i, i];
                result = v * d;
            }
            return result;
        }
        /// <summary>
        /// Returns the Svd decomposition of the current matrix. Recall A = U * S * V'.
        /// </summary>
        /// <returns>Return Svd decomposition U = [0], S = [1], V = [2].</returns>
        public <#= @class #>[] Svd()
        {
            return this.Svd((<#= @value #>)1e-10);
        }
        /// <summary>
        /// Returns the Svd decomposition of the current matrix. Recall A = U * S * V'.
        /// </summary>
        /// <param name="tolerance">Tolerance used for accuracy of algorithm.</param>
        /// <returns>Return Svd decomposition U = [0], S = [1], V = [2].</returns>
        public <#= @class #>[] Svd(<#= @value #> tolerance)
        {
            <#= @class #>[] result;
            if (this.Dimensions.Height >= this.Dimensions.Width)
                result = this.SvdHelper(tolerance);
            else
            {
                result = this.Transpose().SvdHelper(tolerance);
                result = new <#= @class #>[] { result[2], result[1].Transpose(), result[0] };
            }
            return result;
        }
        /// <summary>
        /// See Algorithm 8.6.2 (The SVD Algorithm).
        /// Returns the Svd decomposition of the current matrix. Recall A = U * S * V'.
        /// Height of matrix must be greater or equal to width.
        /// </summary>
        /// <param name="tolerance">Tolerance used for accuracy of algorithm.</param>
        /// <returns>Return Svd decomposition U = [0], S = [1], V = [2].</returns>
        <#= @class #>[] SvdHelper(<#= @value #> tolerance)
        {
            <#= @class #>[] result;
            int m = this.Dimensions.Height;
            int n = this.Dimensions.Width;
            if (m == 1 && n == 1)
                result = new <#= @class #>[] { <#= @class #>.Identity(1), this, <#= @class #>.Identity(1) };
            else
            {
                <#= @class #>[] ubv = this.BiDiagonalization();
                <#= @class #> u = ubv[0];
                <#= @class #> b = ubv[1]; //.Platformct(0, n, 0, n);
                <#= @class #> v = ubv[2];
                int q = 0;
                while (q < n)
                {
                    for (int i = 0; i < n - 1; i++)
                        if (Kean.Math.<#= @class #>.Absolute(b[i + 1, i]) < tolerance * (Kean.Math.<#= @class #>.Absolute(b[i, i]) + Kean.Math.<#= @class #>.Absolute(b[i + 1, i + 1])))
                            b[i + 1, i] = 0;
                    <#= @class #> b22;
                    int p = 0;
                    q = 0;
                    int b22Order = 0;
                    int j = n - 1;
                    for (; j >= 1; j--)
                    {
                        if (Kean.Math.<#= @class #>.Absolute(b[j, j - 1]) < tolerance)
                            q++;
                        else
                            break;
                    }
                    if (j == 0 && q > 0)
                        q++;
                    for (; j >= 1; j--)
                    {
                        if (Kean.Math.<#= @class #>.Absolute(b[j, j - 1]) > tolerance)
                            b22Order++;
                        else
                            break;
                    }
                    if (b22Order > 0)
                        b22Order++;
                    p = n - b22Order - q;
                    if (b22Order == 0)
                        break;
                    if (q < n)
                    {
                        b22 = b.Extract(p, n - q, p, n - q);
                        bool zeros = false;
                        for (int i = 0; i < b22.Dimensions.Width; i++)
                            if (Kean.Math.<#= @class #>.Absolute(b22[i, i]) < tolerance && Kean.Math.<#= @class #>.Absolute(b22[i + 1, i]) > tolerance)
                            {
                                b22[i, i] = 0;
                                b22[i + 1, i] = 0;
                                zeros = true;
                            }
                        if (!zeros)
                        {
                            <#= @class #>[] gkubv = b22.GolubKahanSvdStep();
                            <#= @class #> uprime = <#= @class #>.Diagonal(<#= @class #>.Identity(p), gkubv[0], <#= @class #>.Identity(q + m - n));
                            <#= @class #> vprime = <#= @class #>.Diagonal(<#= @class #>.Identity(p), gkubv[2], <#= @class #>.Identity(q));
                            u = u * uprime;
                            v = v * vprime;
                            b = uprime.Transpose() * b * vprime;
                        }
                    }


                }
                result = new <#= @class #>[] { u, b, v };
            }
            return result;
        }
        /// <summary>
        /// See Algorithm 8.6.1 (Golub-Kahan SVD Step.)
        /// </summary>
        /// <returns></returns>
        <#= @class #>[] GolubKahanSvdStep()
        {
            <#= @class #> b = this.Copy();
            int m = b.Dimensions.Height;
            int n = b.Dimensions.Width;
            <#= @class #> t = b.Transpose() * b;
            <#= @class #> trail = t.Extract(n - 2, n, n - 2, n);
            <#= @value #> d = (trail[0, 0] - trail[1, 1]) / 2;
            <#= @value #> mu = trail[1, 1] + d - Kean.Math.<#= @class #>.Sign(d) * Kean.Math.<#= @class #>.SquareRoot(Kean.Math.<#= @class #>.Squared(d) + Kean.Math.<#= @class #>.Squared(trail[1, 0]));
            <#= @value #> y = t[0, 0] - mu;
            <#= @value #> z = t[1, 0];
            <#= @class #> u = <#= @class #>.Identity(m);
            <#= @class #> v = <#= @class #>.Identity(n);
            for (int k = 0; k < n - 1; k++)
            {
                <#= @value #>[] cs = <#= @class #>.Givens(y, z);
                <#= @class #> g = <#= @class #>.GivensRotation(m, k, k + 1, cs[0], cs[1]);
                v = v * g;
                b = b * g;
                y = b[k, k];
                z = b[k, k + 1];
                cs = <#= @class #>.Givens(y, z);
                g = <#= @class #>.GivensRotation(n, k, k + 1, cs[0], cs[1]);
                b = g.Transpose() * b;
                u = u * g;
                if (k < n - 2)
                {
                    y = b[k + 1, k];
                    z = b[k + 2, k];
                }
            }
            return new <#= @class #>[] { u, b, v };
        }
        /// <summary>
        /// Givens rotation. Creates an identity matrix of given order m and
        /// replace at positions (i,i) and (k,k) with c, 
        /// replace at positions (i,k)  -s and (k,i) with s,
        /// </summary>
        /// <param name="m">Order of matrix to be created.</param>
        /// <param name="i">First index.</param>
        /// <param name="k">Second index.</param>
        /// <param name="c">Value corresponding to a cosine value.</param>
        /// <param name="s">Value corresponding to a sine value.</param>
        /// <returns>Returns a Givens rotation.</returns>
        static <#= @class #> GivensRotation(int m, int i, int k, <#= @value #> c, <#= @value #> s)
        {
            <#= @class #> result = <#= @class #>.Identity(m);
            result[i, i] = c;
            result[k, k] = c;
            result[k, i] = s;
            result[i, k] = -s;
            return result;
        }
        /// <summary>
        /// See Algorithm 5.1.3.
        /// </summary>
        /// <param name="a"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        static <#= @value #>[] Givens(<#= @value #> a, <#= @value #> b)
        {
            <#= @value #>[] result = new <#= @value #>[2];
            <#= @value #> c, s;
            if (b == 0)
            {
                c = 1;
                s = 0;
            }
            else
            {
                if (Kean.Math.<#= @class #>.Absolute(b) > Kean.Math.<#= @class #>.Absolute(a))
                {
                    <#= @value #> tau = -a / b;
                    s = 1 / Kean.Math.<#= @class #>.SquareRoot(1 + Kean.Math.<#= @class #>.Squared(tau));
                    c = s * tau;
                }
                else
                {
                    <#= @value #> tau = -b / a;
                    c = 1 / Kean.Math.<#= @class #>.SquareRoot(1 + Kean.Math.<#= @class #>.Squared(tau));
                    s = c * tau;
                }
            }
            result[0] = c;
            result[1] = s;
            return result;
        }
        #endregion
        #region Lup Methods
        /// <summary>
        /// See http://en.wikipedia.org/wiki/LUP_decomposition.
        /// Lup decomposition of the current matrix. Recall that Lup decomposition is A = LUP, 
        /// where L is lower triangular, U is upper triangular, and P is a permutation matrix.
        /// </summary>
        /// <returns>Returns the Lup decomposition. L = [0], U = [1], P = [2].</returns>
        <#= @class #>[] LupDecomposition()
        {
            if (!this.IsSquare)
                throw new Exception.InvalidDimensions();
            int order = this.Order;
            <#= @class #> l = <#= @class #>.Identity(order);
            <#= @class #> u = this.Copy();
            <#= @class #> p = <#= @class #>.Identity(order);


            int last = order - 1;
            for (int position = 0; position < last; position++)
            {
                int pivotRow = position;
                for (int y = position + 1; y < u.Dimensions.Height; y++)
                    if (Kean.Math.<#= @class #>.Absolute(u[position, position]) < Kean.Math.<#= @class #>.Absolute(u[position, y]))
                        pivotRow = y;
                p.SwapRows(position, pivotRow);
                u.SwapRows(position, pivotRow);
                if (u[position, position] != 0)
                {
                    for (int y = position + 1; y < order; y++)
                    {
                        <#= @value #> pivot = u[position, y] / u[position, position];
                        for (int x = position; x < order; x++)
                            u[x, y] -= pivot * u[x, position];
                        u[position, y] = pivot;
                    }
                }
            }
            for (int y = 0; y < order; y++)
                for (int x = 0; x < y; x++)
                {
                    l[x, y] = u[x, y];
                    u[x, y] = 0;
                }
            return new <#= @class #>[] { l, u, p };
        }
        void SwapRows(int row1, int row2)
        {
            int order = this.Order;
            if (row1 != row2)
            {
                for (int x = 0; x < order; x++)
                {
                    <#= @value #> buffer = this[x, row1];
                    this[x, row1] = this[x, row2];
                    this[x, row2] = buffer;
                }
            }
        }
        /// <summary>
        /// Forward solver lower * x = y. Current object is y. 
        /// </summary>
        /// <param name="lower">Lower triangual matrix.</param>
        /// <returns>Solution x.</returns>
        <#= @class #> ForwardSubstitution(<#= @class #> lower)
        {
            <#= @class #> result = new <#= @class #>(this.Dimensions);
            for (int x = 0; x < this.Dimensions.Width; x++)
            {
                for (int y = 0; y < this.Dimensions.Height; y++)
                {
                    <#= @value #> accumulator = this[x, y];
                    for (int x2 = 0; x2 < y; x2++)
                        accumulator -= lower[x2, y] * result[x, x2];
                    <#= @value #> value = lower[y, y];
                    if (value != 0)
                        result[x, y] = accumulator / value;
                    else
                        throw new Exception.DivisionByZero();
                }
            }
            return result;
        }
        /// <summary>
        /// Backward solver upper * x = y. Current object is y. 
        /// </summary>
        /// <param name="lower">Upper triangual matrix.</param>
        /// <returns>Solution x.</returns>
        <#= @class #> BackwardSubstitution(<#= @class #> upper)
        {
            <#= @class #> result = new <#= @class #>(this.Dimensions);
            for (int x = 0; x < this.Dimensions.Width; x++)
            {
                for (int y = this.Dimensions.Height - 1; y >= 0; y--)
                {
                    <#= @value #> accumulator = this[x, y];
                    for (int x2 = y + 1; x2 < upper.Dimensions.Width; x2++)
                        accumulator -= upper[x2, y] * result[x, x2];
                    <#= @value #> value = upper[y, y];
                    if (value != 0)
                        result[x, y] = accumulator / value;
                    else
                        throw new Exception.DivisionByZero();
                }
            }
            return result;
        }
        /// <summary>
        /// Lup least square solver A * x = y.
        /// The current matrix determines the matrix A above.
        /// </summary>
        /// <param name="y">The right hand column y vector of the equation system.</param>
        /// <returns>Return the least square solution to the system.</returns>
        public <#= @class #> SolveLup(<#= @class #> y)
        {
            <#= @class #> result = null;
            if (this.Dimensions.Width > this.Dimensions.Height)
                throw new Exception.InvalidDimensions();
            else
                try
                {
                    if (this.IsSquare)
                    {
                        <#= @class #>[] lup = this.LupDecomposition();
                        result = (lup[2] * y).ForwardSubstitution(lup[0]).BackwardSubstitution(lup[1]);
                    }
                    else
                    {
                        <#= @class #> transpose = this.Transpose();
                        <#= @class #>[] lup = (transpose * this).LupDecomposition();
                        result = (lup[2] * transpose * y).ForwardSubstitution(lup[0]).BackwardSubstitution(lup[1]);
                    }
                }
                catch (Kean.Error.Exception e)
                {
                }
            return result;
        }
        /// <summary>
        /// Best optimized least square solver A * x = y. The current matrix determines the matrix A above.
        /// </summary>
        /// <param name="y">The right hand column y vector of the equation system.</param>
        /// <returns>Return the least square solution to the system or null if no such is found.</returns>
        public <#= @class #> Solve(<#= @class #> y)
        {
            return this.SolveLup(y);
        }
        /// <summary>
        /// Computes the inverse of the current matrix using Lup-decomposition.
        /// </summary>
        /// <returns>Inverse of the current matrix.</returns>
        public <#= @class #> Inverse()
        {
            if (!this.IsSquare)
                throw new Exception.InvalidDimensions();
            <#= @class #> result = null;
            <#= @class #>[] lup = this.LupDecomposition();
            try
            {
                result = (lup[2] * <#= @class #>.Identity(this.Order)).ForwardSubstitution(lup[0]).BackwardSubstitution(lup[1]);
            }
            catch (Kean.Error.Exception e)
            {
            }
            return result;
        }
        /// <summary>
        /// Computes the determinant of the current matrix using the Lup-decomposition.
        /// </summary>
        /// <returns>Determinant of the current matrix.</returns>
        /// <summary>
        /// Sign of a permutation matrix.
        /// </summary>
        /// <returns>Returns the sign of the permutation matrix.</returns>
        <#= @value #> Sign()
        {
            int[] permutation = new int[this.Dimensions.Height];
            for (int y = 0; y < this.Dimensions.Width; y++)
            {
                int x = 0;
                while (this[x, y] == 0 && x < this.Dimensions.Width)
                    x++;
                permutation[y] = x;
            }
            <#= @value #> accumulated = 1;
            for (int i = 0; i < permutation.Length; i++)
                for (int j = i + 1; j < permutation.Length; j++)
                    accumulated *= (<#= @value #>)(permutation[i] - permutation[j]) / (i - j);
            return Kean.Math.<#= @class #>.Sign(accumulated);
        }
        #endregion
        #region Static Constructors
        /// <summary>
        /// Creates an identity matrix of given order.
        /// </summary>
        /// <param name="order">Order of matrix to be created.</param>
        /// <returns>Identity matrix of given order.</returns>
        public static <#= @class #> Identity(int order)
        {
            <#= @class #> result = new <#= @class #>(order, order);
            for (int i = 0; i < order; i++)
                result[i, i] = 1;
            return result;
        }
        /// <summary>
        /// Creates a diagonal block matrix with block given. Outside blocks the matrix has zero elements.
        /// </summary>
        /// <param name="matrices">Matrices to be on the diagonal of the created matrix.</param>
        /// <returns>Block diagonal matrix.</returns>
        public static <#= @class #> Diagonal(params <#= @class #>[] matrices)
        {
            int width = 0;
            int height = 0;
            for (int i = 0; i < matrices.Length; i++)
            {
                width += matrices[i].Dimensions.Width;
                height += matrices[i].Dimensions.Height;
            }
            <#= @class #> result = new <#= @class #>(width, height);
            int k = 0;
            int l = 0;
            for (int i = 0; i < matrices.Length; i++)
            {
                result.Set(k, l, matrices[i]);
                k += matrices[i].Dimensions.Width;
                l += matrices[i].Dimensions.Height;
            }
            return result;
        }
        /// <summary>
        /// Create a matrix from a two-dimensional array of matrices 
        /// such that the given matrices become sub-block-matrices in the 
        /// construted matrix.
        /// </summary>
        /// <param name="matrices"></param>
        /// <returns></returns>
        public static <#= @class #> Block(<#= @class #>[,] matrices)
        {
            <#= @class #> result;
            int width = 0;
            int height = 0;
            int blockWidth = matrices.GetLength(0);
            int blockHeight = matrices.GetLength(1);
            for (int x = 0; x < blockWidth; x++)
            {
                for (int y = 0; y < blockHeight; y++)
                {
                    if (matrices[x, 0].Dimensions.Width != matrices[x, y].Dimensions.Width ||
                    matrices[0, y].Dimensions.Height != matrices[x, y].Dimensions.Height)
                        throw new Exception.InvalidDimensions();
                }
            }
            for (int x = 0; x < blockWidth; x++)
                width += matrices[x, 0].Dimensions.Width;
            for (int y = 0; y < blockHeight; y++)
                height += matrices[0, y].Dimensions.Height;
            result = new <#= @class #>(width, height);
            width = 0;
            height = 0;
            for (int x = 0; x < blockWidth; x++)
            {
                for (int y = 0; y < blockHeight; y++)
                {
                    <#= @class #> block = matrices[x, y];
                    for (int xx = 0; xx < block.Dimensions.Width; xx++)
                        for (int yy = 0; yy < block.Dimensions.Height; yy++)
                            result[width + xx, height + yy] = block[xx, yy];
                    height += matrices[0, y].Dimensions.Height;
                }
                width += matrices[x, 0].Dimensions.Width;
                height = 0;
            }
            return result;
        }
        /// <summary>
        /// Column basis vector of given length and with a one a given index.
        /// </summary>
        /// <param name="length">Length of column to be created.</param>
        /// <param name="index">Index to set the one.</param>
        /// <returns>Column vector matrix of given length and a one at given index.</returns>
        public static <#= @class #> Basis(int length, int index)
        {
            return <#= @class #>.Basis(length, index, true);
        }
        /// <summary>
        /// Column / Row basis vector of given length and with a one a given index.
        /// </summary>
        /// <param name="length">Length of column to be created.</param>
        /// <param name="index">Index to set the one.</param>
        /// <param name="column">Column vector if set to true, row vector if set to false.</param>
        /// <returns>Column / Row vector matrix of given length and a one at given index.</returns>
        public static <#= @class #> Basis(int length, int index, bool column)
        {
            <#= @class #> result = new <#= @class #>(1, length);
            result[0, index] = 1;
            if (!column)
                result = result.Transpose();
            return result;
        }
        #endregion
        #region Object overides and IEquatable<<#= @class #>>
        public override bool Equals(object other)
        {
            return (other is <#= @class #>) && this.Equals(other as <#= @class #>);
        }
        // other is not null here.
        public bool Equals(<#= @class #> other)
        {
            bool result = this.Dimensions == other.Dimensions;
            if (result)
            {
                for (int x = 0; x < this.Dimensions.Width; x++)
                    for (int y = 0; y < this.Dimensions.Height; y++)
                        result &= this[x, y] == other[x, y];
            }
            return result;
        }
        public override int GetHashCode()
        {
            int result = this.Dimensions.GetHashCode();
            for (int i = 0; i < this.Dimensions.Area; i++)
                result ^= this.elements[i].GetHashCode();
            return result;
        }
        public override string ToString()
        {
            System.Text.StringBuilder builder = new System.Text.StringBuilder();
            for (int y = 0; y < this.Dimensions.Height; y++)
                for (int x = 0; x < this.Dimensions.Width; x++)
                {
                    builder.Append((Kean.Math.<#= @class #>.ToString(this[x, y])));
                    builder.Append((x == this.Dimensions.Width - 1) ? ((y == this.Dimensions.Height - 1) ? "" : "; ") : ", ");
                }
            return builder.ToString();
        }
        #endregion
        #region Comparison Functions and IComparable<<#= @class #>>
        public static bool operator ==(<#= @class #> left, <#= @class #> right)
        {
            return
                left.Same(right) || (left.NotNull() && right.NotNull()) &&
                left.Equals(right);
        }
        public static bool operator !=(<#= @class #> left, <#= @class #> right)
        {
            return !(left == right);
        }
        #endregion
        #region Casts
        public static explicit operator <#= @class #>(<#= @value #>[] value)
        {
            <#= @class #> result = new <#= @class #>(1, value.Length);
            Array.Copy(value, result.elements, value.Length);
            return result;
        }
        public static explicit operator <#= @value #>[](<#= @class #> value)
        {
            <#= @value #>[] result = new <#= @value #>[value.elements.Length];
            Array.Copy(value.elements, result, result.Length);
            return result;
        }
        public static explicit operator <#= @value #>[,](<#= @class #> value)
        {
            <#= @value #>[,] result = new <#= @value #>[value.Dimensions.Width, value.Dimensions.Height];
            for (int x = 0; x < value.Dimensions.Width; x++)
                for (int y = 0; y < value.Dimensions.Height; y++)
                    result[x, y] = value[x, y];
            return result;
        }
        public static explicit operator <#= @class #>(<#= @value #>[,] value)
        {
            <#= @class #> result = new <#= @class #>(value.GetLength(0), value.GetLength(1));
            for (int x = 0; x < result.Dimensions.Width; x++)
                for (int y = 0; y < result.Dimensions.Height; y++)
                    result[x, y] = value[x, y];
            return result;
        }
        #endregion
    }
}
<#+
    }  
#>