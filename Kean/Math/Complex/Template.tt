<#@ template language="C#v3.5" hostspecific="True" #>
<#
    GenerateFile("Single", "float");
    SaveOutput("Single.cs");  
    GenerateFile("Double", "double");
    SaveOutput("Double.cs");  
#>
<#+
  void SaveOutput(string outputFileName)
  {
      string templateDirectory = System.IO.Path.GetDirectoryName(Host.TemplateFile);
      string outputFilePath = System.IO.Path.Combine(templateDirectory, outputFileName);
      System.IO.File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString()); 
      this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
  }
#>
<#+
    void GenerateFile(string @class, string @value)
    {
#>
// 
//  <#= @class #>.cs (generated by template)
//  
//  Author:
//       Anders Frisk <andersfrisk77@gmail.com>
//  
//  Copyright (c) 2011 Anders Frisk
// 
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU Lesser General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
// 
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU Lesser General Public License for more details.
// 
//  You should have received a copy of the GNU Lesser General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
using System;
using Kean.Extension;
namespace Kean.Math.Complex
{
    public struct <#= @class #>
    {
        public <#= @value #> Real;
        public <#= @value #> Imaginary;
        public <#= @class #> Conjugate { get { return new <#= @class #>(this.Real, -this.Imaginary); } }
        public <#= @value #> AbsoluteValue { get { return Kean.Math.<#= @class #>.SquareRoot(Kean.Math.<#= @class #>.Squared(this.Real) + Kean.Math.<#= @class #>.Squared(this.Imaginary)); } }
        public <#= @class #>(<#= @value #> real, <#= @value #> imaginary)
        {
            this.Real = real;
            this.Imaginary = imaginary;
        }
        #region Static Operators
        public static <#= @class #> operator +(<#= @class #> left, <#= @class #> right)
        {
            return new <#= @class #>(left.Real + right.Real, left.Imaginary + right.Imaginary);
        }
        public static <#= @class #> operator -(<#= @class #> left, <#= @class #> right)
        {
            return new <#= @class #>(left.Real - right.Real, left.Imaginary - right.Imaginary);
        }
        public static <#= @class #> operator -(<#= @class #> value)
        {
            return new <#= @class #>(-value.Real, -value.Imaginary);
        }
        public static <#= @class #> operator *(<#= @class #> left, <#= @class #> right)
        {
            return new <#= @class #>(left.Real * right.Real - left.Imaginary * right.Imaginary, left.Real * right.Imaginary + left.Imaginary * right.Real);
        }
        public static <#= @class #> operator *(<#= @value #> left, <#= @class #> right)
        {
            return new <#= @class #>(left * right.Real, left * right.Imaginary);
        }
        public static <#= @class #> operator /(<#= @class #> left, <#= @value #> right)
        {
            return new <#= @class #>(left.Real / right, left.Imaginary / right);
        }
        public static <#= @class #> operator /(<#= @class #> left, <#= @class #> right)
        {
            return (left * right.Conjugate) / Kean.Math.<#= @class #>.Squared(right.AbsoluteValue);
        }
        #endregion
        #region Fourier
        /// <summary>
        /// Discrete Fourier transform. Input array of arbitrary size.
        /// </summary>
        /// <param name="input">Input array to be transformed.</param>
        /// <returns>Output Fourier transformed array.</returns>
        public static <#= @class #>[] DiscreteTransform(<#= @class #>[] input)
        {
            <#= @class #>[] result = new <#= @class #>[input.Length];
            if (input.Length > 0)
            {
                for (int i = 0; i < input.Length; i++)
                    for (int j = 0; j < input.Length; j++)
                        result[i] += input[j] * <#= @class #>.RootOfUnity(input.Length, -i * j);
            }
            return result;
        }
        /// <summary>
        /// Inverse discrete Fourier transform. Input array of arbitrary size. 
        /// </summary>
        /// <param name="input">Input array to be transformed.</param>
        /// <returns>Output Fourier transformed array.</returns>
        public static <#= @class #>[] InverseDiscreteTransform(<#= @class #>[] input)
        {
            return input.Length > 0 ? <#= @class #>.DiscreteTransform(input.Map(c => c.Conjugate)).Map(c => c.Conjugate / (<#= @value #>)input.Length) : new <#= @class #>[0];
        }
        /// <summary>
        /// Fast Fourier transform. Input array must have a length which is a power of 2.
        /// </summary>
        /// <param name="input">Input array to be transformed.</param>
        /// <returns>Output Fourier transformed array.</returns>
        public static <#= @class #>[] FastTransform(<#= @class #>[] input)
        {
            <#= @class #>[] result = new <#= @class #>[input.Length];
            if (input.Length == 1)
                result[0] = input[0];
            else if (input.Length > 1)
            {
                int halfLength = input.Length / 2;
                <#= @class #>[] evenInput = new <#= @class #>[halfLength];
                for (int i = 0; i < evenInput.Length; i++)
                    evenInput[i] = input[2 * i];
                <#= @class #>[] oddInput = new <#= @class #>[halfLength];
                for (int i = 0; i < oddInput.Length; i++)
                    oddInput[i] = input[2 * i + 1];
                <#= @class #>[] evenOutput = <#= @class #>.FastTransform(evenInput);
                <#= @class #>[] oddOutput = <#= @class #>.FastTransform(oddInput);
                for (int i = 0; i < halfLength; i++)
                {
                    <#= @class #> root = <#= @class #>.RootOfUnity(input.Length, -i);
                    result[i] = evenOutput[i] + root * oddOutput[i];
                    result[halfLength + i] = evenOutput[i] - root * oddOutput[i];
                }
            }
            return result;
        }
        /// <summary>
        /// Inverse fast Fourier transform. nput array must have a length which is a power of 2.
        /// </summary>
        /// <param name="input">Input array to be transformed.</param>
        /// <returns>Output Fourier transformed array.</returns>
        public static <#= @class #>[] InverseFastTransform(<#= @class #>[] input)
        {
            return input.Length > 0 ? <#= @class #>.FastTransform(input.Map(c => c.Conjugate)).Map(c => c.Conjugate / (<#= @value #>)input.Length) : new <#= @class #>[0];
        }
        #endregion
        #region Static Functions
        public static <#= @class #> Exponential(<#= @class #> value)
        {
            return Kean.Math.<#= @class #>.Exponential(value.Real) * new <#= @class #>(Kean.Math.<#= @class #>.Cosinus(value.Imaginary), Kean.Math.<#= @class #>.Sinus(value.Imaginary));
        }
        public static <#= @class #> Logarithm( <#= @class #> value)
        {
            return Kean.Math.<#= @class #>.Logarithm(value.AbsoluteValue) + new <#= @class #>(0, Kean.Math.<#= @class #>.ArcusTangensExtended(value.Imaginary, value.Real));
        }
        public static <#= @class #> RootOfUnity(int n)
        {
            return <#= @class #>.RootOfUnity(n, 1);
        }
        public static <#= @class #> RootOfUnity(int n, int k)
        {
            return <#= @class #>.Exponential(new <#= @class #>(0, 2 * k * Kean.Math.<#= @class #>.PI / n));
        }
        #endregion
        #region Object overides and IEquatable<<#= @class #>>
        public override bool Equals(object other)
        {
            return (other is <#= @class #>) && this.Equals((<#= @class #>)other);
        }
        // other is not null here.
        public bool Equals(<#= @class #> other)
        {
            return this.Real == other.Real && this.Imaginary == other.Imaginary;
        }
        public bool Equals(<#= @class #> other, double tolerance)
        {
            return Kean.Math.<#= @class #>.Absolute(this.Real - other.Real) < tolerance && Kean.Math.<#= @class #>.Absolute(this.Imaginary - other.Imaginary) < tolerance;
        }
        public override int GetHashCode()
        {
            return this.Real.GetHashCode() ^ this.Imaginary.GetHashCode();
        }
        public override string ToString()
        {
            return Kean.Math.<#= @class #>.ToString(this.Real) + " " + (Kean.Math.<#= @class #>.Sign(this.Imaginary) >= 0 ? "+" : "") + Kean.Math.Double.ToString(this.Imaginary) + "i";
        }
        #endregion
        #region Comparison Functions and IComparable<<#= @class #>>
        public static bool operator ==(<#= @class #> left, <#= @class #> right)
        {
            return left.Equals(right);
        }
        public static bool operator !=(<#= @class #> left, <#= @class #> right)
        {
            return !(left == right);
        }
        #endregion
        #region Casts
        public static implicit operator <#= @class #>(<#= @value #> value)
        {
            return new <#= @class #>(value, 0);
        }
        public static implicit operator string(<#= @class #> value)
        {
            return value.ToString();
        }
        public static implicit operator <#= @class #>(string value)
        {
            <#= @class #> result = new <#= @class #>();
            if (value.NotEmpty())
            {
                try
                {
                    value = value.ToLower().Replace(" ", "").Replace("f", "").Replace("\t", "");
                    if (!value.Contains("i"))
                        result = Kean.Math.<#= @class #>.Parse(value);
                    else
                    {
                        string[] values = value.Split(new char[] { '+', '-' }, StringSplitOptions.RemoveEmptyEntries);
                        if (values.Length == 1)
                            result = new <#= @class #>(0, Kean.Math.<#= @class #>.Parse(value.Trim('i', '*')));
                        else
                        {
                            string real = null;
                            string imaginary = null;
                            if (values[0].Contains("i"))
                            {
                                int index = value.IndexOf(values[0]);
                                char sign = index >= 1 && value[index - 1] == '-' ? '-' : '+';
                                imaginary = sign + values[0].Trim('i', '*');
                                index = value.IndexOf(values[1]);
                                sign = index >= 1 && value[index - 1] == '-' ? '-' : '+';
                                real = sign + values[1];
                            }
                            else if (values[1].Contains("i"))
                            {
                                int index = value.IndexOf(values[1]);
                                char sign = index >= 1 && value[index - 1] == '-' ? '-' : '+';
                                imaginary = sign + values[1].Trim('i', '*');
                                index = value.IndexOf(values[0]);
                                sign = index >= 1 && value[index - 1] == '-' ? '-' : '+';
                                real = sign + values[0];
                            }
                            if (real.NotEmpty() && imaginary.NotEmpty())
                                result = new <#= @class #>(Kean.Math.<#= @class #>.Parse(real), Kean.Math.<#= @class #>.Parse(imaginary));
                        }
                    }
                }
                catch
                { }
            }
            return result;
        }
        #endregion
    }
}
<#+
    }  
#>